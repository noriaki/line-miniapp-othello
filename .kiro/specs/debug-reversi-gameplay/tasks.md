# 実装タスク: debug-reversi-gameplay

## タスク概要

このドキュメントは、dev3000を活用したリバーシゲームのデバッグ作業を探索的に実施するための実装タスクリストです。Claude Codeが自律的にゲームプレイを完遂し、発見された問題を仮説検証アプローチで解決していきます。

## タスクリスト

- [ ] 1. dev3000デバッグ環境のセットアップと初期状態確認
  - dev3000が正常に起動していることを確認する
  - MCP サーバーとの通信を確立する
  - Timeline Dashboard (http://localhost:3684/logs) へアクセス可能であることを確認する
  - ブラウザ監視（Playwright）が正常に動作していることを検証する
  - リバーシゲームへのアクセスパス（http://localhost:3000）を確認する
  - _Requirements: 1.1, 1.2_

- [ ] 2. ゲーム初期表示の検証とベースライン確立
  - ゲーム開始画面へナビゲートする
  - 初期盤面（黒白各2石の配置）が正しく表示されることを確認する
  - UI状態のスナップショットを取得し、期待される要素が存在するか検証する
  - 初回アクセス時のエラーログ、ネットワークリクエスト、コンソールメッセージを収集する
  - WebAssembly（ai.wasm）が正常にロードされているか確認する
  - _Requirements: 2.1, 1.3, 6.1, 6.4_

- [ ] 3. プレーヤーの手の実行とゲームロジック検証

- [ ] 3.1 プレーヤーの有効な手の配置機能を検証する
  - 初期盤面から有効な手の一覧を特定する
  - プレーヤーが有効な手を打つ操作を実行する
  - 石が正しく配置され、該当する石が反転されることを確認する
  - 反転処理が正しく実行されているか、盤面の状態を検証する
  - 操作後のコンソールログとエラーメッセージを確認する
  - _Requirements: 2.2, 2.4, 1.3_

- [ ] 3.2 エラー発生時の詳細情報収集と仮説立案
  - エラーが発生した場合、エラーメッセージとスタックトレースを記録する
  - 発生箇所のスクリーンショットを取得する
  - 関連するコンポーネントのソースコードを特定する
  - エラーパターンを分類し、tasks.mdに仮説と検証手順を記載する
  - Opusモデルを活用して複雑な問題の分析を行う
  - _Requirements: 3.1, 3.2, 3.3, 8.2, 8.4_

- [ ] 4. AIプレーヤーの動作検証と統合テスト

- [ ] 4.1 AIの手番実行と計算結果の検証
  - プレーヤーの手を打った後、AIの手番が開始されることを確認する
  - WebAssembly（ai.wasm）がAIの手を計算することを検証する
  - 計算結果が有効な手であることを確認する
  - AI が石を配置し、反転処理が正しく実行されることを検証する
  - AI計算中のUIの応答性を確認する（Web Worker実行の確認）
  - _Requirements: 2.3, 4.1, 4.4_

- [ ] 4.2 AI関連エラーの診断とインタフェース検証
  - AIが無効な手を返す、または計算に失敗した場合にエラーログを記録する
  - ai.jsのGlueコードとのインタフェースを検証する
  - wasm-source-analysisディレクトリの解析レポートを参照してWASMインタフェース情報を確認する
  - Egaroucidソースコード（.analysis/egaroucid/src）のWebファイルを参照して実装詳細を確認する
  - エラー原因の仮説を立て、検証方法を定義する
  - _Requirements: 4.2, 4.3, 4.5, 4.6, 3.2, 6.2_

- [ ] 5. ゲームフローの継続とパス処理の検証

- [ ] 5.1 交互プレイの連続実行と手番管理
  - プレーヤーとAIが交互に手を打つフローを複数回実行する
  - 現在の手番プレーヤーが明確に表示されることを確認する
  - 各手の実行後に盤面状態が正しく更新されることを検証する
  - ゲーム進行中のエラーやUI表示の不整合を監視する
  - _Requirements: 2.5, 1.4_

- [ ] 5.2 有効な手が存在しない場合のパス処理
  - 有効な手が存在しない状況を作り出すか検出する
  - パスが正しく実行され、相手に手番が移ることを確認する
  - パス処理が連続して発生する場合（両プレーヤーともパス）の動作を検証する
  - パス時のUIメッセージやフィードバックが適切であることを確認する
  - _Requirements: 2.6_

- [ ] 6. ゲーム終了処理の検証と結果表示

- [ ] 6.1 ゲーム終了条件の検証
  - 盤面が全て埋まる条件でゲームが終了することを確認する
  - 両プレーヤーとも有効な手がない条件でゲームが終了することを確認する
  - ゲーム終了判定が正しく実行されることを検証する
  - _Requirements: 2.7_

- [ ] 6.2 勝敗判定と結果表示の検証
  - ゲーム終了時に両プレーヤーの石数が正しく表示されることを確認する
  - 勝敗結果（勝ち、負け、引き分け）が正しく判定され表示されることを検証する
  - 盤面リセットオプションが表示され、機能することを確認する
  - リセット後に新しいゲームが正常に開始できることを検証する
  - _Requirements: 2.8_

- [ ] 7. 探索的デバッグプロセスの実践と記録管理

- [ ] 7.1 デバッグセッションの体系的な記録
  - 各検証タスクをtasks.mdに作成し、進捗を更新する
  - 検証完了時にタスクに完了マークを付け、結果サマリーを追記する
  - 複数の仮説が存在する場合、各仮説を独立したタスクとして管理する
  - 過去の検証履歴を参照し、リグレッション防止に活用する
  - _Requirements: 5.1, 5.2, 5.3, 5.4, 5.5_

- [ ] 7.2 コード変更のチェックポイント管理
  - 仮説検証が完了するたびに、検証結果を含むコミットを作成する
  - コミットメッセージにエラー内容、仮説、検証方法、変更内容を含める
  - 各検証を個別のチェックポイントとしてコミット履歴に記録する
  - デグレーションリスクがある場合、過去の修正履歴を確認し影響を評価する
  - _Requirements: 7.1, 7.2, 7.3, 7.4, 7.5_

- [ ] 8. 多角的情報収集と根本原因分析

- [ ] 8.1 MCPとログによる事実ベースの情報収集
  - dev3000のMCPツールを活用して実際のログとデータを収集する
  - Timeline Dashboardで統合イベントを確認する
  - ブラウザのコンソールログ、ネットワークリクエスト、DOM状態を収集する
  - Playwrightによる自動監視データを活用する
  - _Requirements: 6.1, 6.4, 6.5, 1.5_

- [ ] 8.2 ソースコード分析と外部情報の活用
  - プロジェクトの実装コードを事実ベースで分析する
  - エラー箇所のコンポーネントソースを特定する
  - 必要に応じてWeb検索を活用して関連情報を収集する
  - WASM関連の問題では解析レポートやソースコードを参照する
  - _Requirements: 6.2, 6.3_

- [ ] 9. 包括的な1ゲーム完遂テストと品質確認

- [ ] 9.1 正常系フローの完全実行
  - ゲーム開始から終了までを一度のセッションで完遂する
  - 全ての手順（プレーヤー操作、AI操作、終了処理）がエラーなく動作することを確認する
  - 盤面が全て埋まるまでゲームを進行させる
  - 最終的な勝敗判定と結果表示が正しく機能することを検証する
  - _Requirements: 2.1, 2.2, 2.3, 2.4, 2.5, 2.7, 2.8_

- [ ] 9.2 複数回プレイによる安定性検証
  - 同じフローを複数回繰り返し実行する
  - 再現性のある動作が確認できることを検証する
  - dev3000で検出されるエラーがゼロであることを確認する
  - tasks.mdに全ての問題と解決策が記録されていることを確認する
  - デバッグ作業の成功判定基準をすべて満たしていることを検証する
  - _Requirements: 全要件の統合検証_

- [ ] 10. 柔軟な問題対応と仮説の更新

- [ ] 10.1 予期しない問題への適応的対応
  - 予期しないエラーが発生した場合、柔軟な対応を優先する
  - 問題の原因が不明な場合、試行錯誤と多角的な仮説立案を行う
  - 新しい問題パターンが発見された場合、既存の仮説を更新する
  - 複雑な問題分析にはOpusモデル（ultrathink）を活用する
  - _Requirements: 8.1, 8.2, 8.3, 8.4_

- [ ] 10.2 初期調査と仮説検証の実施
  - MCPとスクリーンショットによる事実収集から調査を開始する
  - 仮説を立てた後、Sonnetモデルを使用して検証を実施する
  - 新たな検証方法を定義し、tasks.mdに記録する
  - 検証結果に基づいて次の調査方針を決定する
  - _Requirements: 8.5, 3.4_

## 成功基準

以下の全ての条件を満たすことでデバッグ作業完了とする：

1. **ゲームの完遂**: リバーシゲームを開始から終了まで一度もエラーなくプレイ完了
2. **全エラーの解決**: dev3000で検出されるエラーがゼロ
3. **安定性の確認**: 複数回のプレイで再現性のある動作
4. **知識の蓄積**: tasks.mdに全ての問題と解決策が記録されている

## 注意事項

- タスクは探索的デバッグの性質上、実際の問題発見に応じて動的に更新される
- 各タスクの完了時には必ず結果サマリーを追記する
- 仮説検証の都度、コミットを作成してチェックポイントとする
- 複雑な分析にはOpusモデル、実行タスクにはSonnetモデルを使い分ける
- 全ての判断は事実（ログ、エラーメッセージ、スクリーンショット）に基づく
